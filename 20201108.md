> wakaTime을 사용해보자
---

## Styled- components

클래스 없는 css 스타일링

css를 짜기 어려울경우 ??


1. 컴포넌트가 너무많으면 css작성하기 어려워짐

2. 실수로 class를 중복으로 만들어버렸다.

3. class선언 없이 컴포넌트에 css를 직접 장착 ( CSS in JS 라고도 한다. )


---

시작

```jsx
import styled from 'styled-components';

```

임포트 해주고

변수를 하나만든다. (컴포넌트를 하나 만든다고 생각해도 된다.)


```jsx

let box = styled.div`
    padding : 20px
`

```

css를 미리입혀놓은 컴포넌트를 만든다.

원하는곳에서

`<box></box>`

padding이 적용된 박스태그가 생성되어있을것이다.

className을 쓰지 않을뿐

클래스로 동작한다 ( 내가 알지못하는 그런 클래스명으로 선언되어있긴하다. )


컴포넌트가 20~30 개가 넘어가면??

클래스명 까먹거나, 중복으로 선언한다거나 하는 그런 실수들을 방지하는 장점이 있지만

단점은??

수십개의 <div>가 아니라 수십개의 <컴포넌트> 를 보게된다.

선택사항이다.

장,단점이 존재..

유용한 문법 하나더

- 비슷한 UI가 몇개 더 필요해 (빨간/파란)

```jsx

let title = styled.h4`
    font-size : 25px;
    color : ${ props => props.색상}
`;

```

`글자${변수명}` : 자바스크립트에서 사용하던 백틱 , 달러 중괄호로 변수불러오던 문법이다. 잊지말자 ( 자주썻었지 )

props.색상 ??


```jsx 
<title 색상 ={'red'}> Detail </title>

```

props는 꼭 중괄호로 전달하지않고 따옴표로만으로도 보낼수도있다.

```jsx 
<title 색상 ="red"> Detail </title>

```

편의성 이런건 적다..

__가장큰 장점 : 컴포넌트가 많아지면 class겹칠 일이 줄어들음__

(하지만 사실은 CSS를 모듈화 해두면 해결 될 일이다!!)


### CSS대신 SASS를 써보자 ( SASS 문법 )

설치방법

1. yarn add node-sass
2. npm install node-sass


SASS ? css를 좀더 프로그래밍언어스럽게 작성가능한 프로세서

css에서 변수 연산자 함수 Extend import 이런걸 사용가능



---

SCSS 또는 SASS 문법으로 작성한 파일은 브라우저에서 읽지못한다.

다시 css문법으로 돌려주는 장치 (라이브러리)

가 바로 node-sass 이다.

알아서 css로 컴파일해준다.

`import '/Detail.css'`

먼저 css파일 분리부터

한다.



그리고 나중에 확장자를 scss로 바꿔주고

import 도 scss로 파일명을 바꿔준다

그런데 ??




Node Sass version 5.0.0 is incompatible with ^4.0.0.

에러가 생겼다 ..

구글링해보자

"node-sass": "^5.0.0",


pakage.json 에서 확인해본겨로가

5.0 라이브러리가 인스톨된게 보이는데

가볍게 스택오버플로우 검색해본겨로가 5.0 버전이 충돌이 심하다느니 뭐 얘기가많다.

yarn add node-scss 를 치면

최신라이브러리가 인스톨되나보다

그러므로 4.14.1 버전이 제일 최적화가 잘되어있느거같다.

`yarn add node-sass@4.14.1`

이렇게 치면 버전을 지정해서 다운받을수있다.

다시

yarn remove node-scss 해서 기존의 패키지를 날려보자

또다른 오류에 직면

error This module isn't specified in a package.json file.


### 패키지이름 node-sass

### 확장자 SCSS

헷갈리지말자..

그냥 단순히 오타였던것이다.

물론 5.0버전에 대한것은 사실인거같아

4.14.1버전으로 다시 yarn add 해보겠다.



> 결과 = 정상적


---


### SASS 문법

1. 변수에 데이터르 저장해서 쓰자.

$변수명 : 변수에 넣을값

```scss

$메인컬러 : #ff0000;

.red {
    color : $메인컬러
}

```

2. @import 파일경로

```scss
@import './reset.scss';
```

보통 _reset.scss 이런식으로 작명한다

딱봤을때 쓸때없는 파일이구나 < 라는게 보이게끔

reset.scss = 

```scss
body{
    margin : 0;
}

div {
    box-sizing : border-box;
}
```

3. 셀렉터 대신 쓰는 nesting 

```scss
div.container{
    h4{
        color : blue;
    }

    p{
        color : green;
    }
}

```

이 기능 이쁘다. h4,p 태그는 div.container 랑 관계가 있는 이것이구나.


4. @extend 라는 문법

```scss

.my-alert{
    background-color: #eeeeee;
    padding: 15px;
    border-radius: 5px;
    max-width: 500px;
    width: 100%;
    margin: auto;
}

.my-alert p {
    margin-bottom: 0;
}

.my-alert-yel{
    @extend .my-alert;
    background : #ffe591;
}

```

이렇게 my-alert의 속성을 @extend로 모두 복붙 할수있다. 


5. @mixin 문법이 있다. 함수라고 생각하자


scss파일 내부에 
@mixin 함수명(){
    긴 내용들
}

이 코드를

긴 내용들을 어딘가에 복붙하려면

@include 함수명() 으로 호출하면된다.

__위에서 함수를 먼저 선언해줘야된다.__

```scss
@mixin 함수(){
    background-color: #eeeeee;
    padding: 15px;
    border-radius: 5px;
    max-width: 500px;
    width: 100%;
    margin: auto;
}

.my-alert{
    @include 함수()
}
```



> sass문법으로 css를 작성하면 코드길이가 많이 줄어든다.


### Lifecycle Hook? useEffect?

Link태그 에러가 있는데 이것을 해결하자

`<Navbar.Link><Link> ...` 이렇게 써있는부분이 있다. App.js에

이는 쉽게생각하면 a태그 안에 a가 또있다고 얘기해주는것인데

waring을 띠운다 여기서

Navbar.Link 자체가 이미 Link태그를 포함한건데

왜 Link태그를 또 썻느냐 ?? 그래서 해결방법은

`<Navbar.Link><Link to="/">...`이렇게 있던것을

`<Navbar.Link to="/"> Home </Navbar.Link>` 이렇게 해버리면된다.



여기에

`<Navbar.Link as={Link} to="/"> Home </Navbar.Link>` 

as={Link} 를 추가해서

이게 무슷뜻이냐면

> 이 Html 태그는 Link 태그처럼 사용해주세요 하는 뜻이다.


---

Lifecycle ? 생명주기이다.

컴포넌트 : 등장이있고 퇴장이있다.

그리고 업데이트 (재렌더링)

라이프사이클 (생명주기) 중간중간에 훅 (낙시줄 끝 바늘)을 걸수있다.

컴포넌트가 생성되기전에 훅을 걸어서

컴포넌트가 삭제되기전에 훅을 걸어서

컴포넌트의 인생 중간중간에 뭔가 명령을 줄 수 있음

> 컴포넌트의 라이프사이클에 일종의 트리거를 걸수있는거같다.


>이전 코드는 이러했다. (옛날 방식 클래스방식 코드)
```jsx

class Detail2 extends React.Component{
    componentDidMount(){
        //컴포넌트가 Mount되었을때 , 생성되었을때 실행
    }
    componentWillUnmount(){
        // 컴포넌트가 삭제되었을때(시야에서안보일때) 실행
    }
}

```

react 16.8? 16.9 이후 부터는 더 좋은 방식(?)의 훅을 쓸수있다.


### useEffect 훅

import React , { useState,useEffect } from 'react';

엔터키만 잘쳐도 알아서 임포트되는경우가 많다.


```jsx

useEffect(()=>{
    // 컴포넌트가 mount되었을때
    // 컴포넌트가 update 될때 (재렌더링)
    console.log(11111)
});

```

alert 창이 2초후에 사라지게 해보자.



```jsx
// --------------------------------
let [alertFlag,alertFlagChange] = useState(true);
    useEffect(()=>{
      //2초 후에 저거 alert 창을 안보이게하자
      setTimeout(()=>{alertFlagChange(!alertFlag)},2000)
    })
      
  return (
    <div className="container">
      <titleBox><Title className='red'>Detail</Title></titleBox>
      
      {
        alertFlag
        ?<MyAlert></MyAlert>
        :null
      }
      ...
  )

// -------------------------------

```

처음에 useState 생각 못하고 그냥 let으로 플래그만들어서 했다가

왜 렌더링이 안돼지? 했다가

뭘 어케해야할까 하다가 state 딱 생각나 버렸다.

flag 도 html 태그에서 어떠한 상태를 변화시킬만한 충분한 가치있는 중요한 데이터이다.

state자료로 만들어야하는게 어찌보면 당연했을지도..모르겟다.

재렌더링을 고려하고 생각했어야했는데 좀 아쉬웠던거같다.

5분도 안걸리긴했다. 찡긋.


추가로 보통 useEffect 내부의 어떤함수들은

let timer 등으로 저장해놓는경우가 많다.

그렇게 하도록하자.

`let timer = setTimeout(()=>{alertFlagChange(!alertFlag)},2000)`


useEffect :  컴포넌트가 사라질때 코드를 실행시킬수도 있다.

return 을 사용하면된다.


```jsx

useEffect(()=>{
    return function 어쩌구(){ 실행할 코드~~~}
    // return ()->{ 실행할 코드~~~}
})

```


useEffect : 여러개의 훅을 걸고 사용하고싶다면.

useEffect를 여러개 적어도 된다.

> __다만 순서대로 실행된다 위에서부터.__


정리하면 

useEffect의 특징

1. 파라미터로 콜백함수를 가진다.

2. 콜백함수에 그대로 특정기능을 부여하면 특정컴포넌트가 마운트(렌더링)될때 실행된다.

3. 콜백함수 내부에 return으로 특정컴포넌트가 언마운트(사라질떄)될때 실행된다.

4. useEffect는 복수존재가 가능하고 작성한 순서대로 동작한다.

