## 모든 문 형태에 적용

if 블록, else 블록 다른 블록 처리

switch문

for 문


블록에 대해 생각해보자.



---

for는 안쪽에만 존재한다

for에서 선언하는 
```js 
for(let i=1;i<=10;i++){
    sum += i;
}
```

for내부 블럭에서 선언한 변수 , 그리고 for조건식? 에서 선언한 변수 또한

for문 블럭의 블럭스코프를 가진다.

---

## let과 const

```JS

let a = 1
function f(){
    console.log(a,b,c)
    let b=2;
    console.log(a,b,c)
    if(true){
        let c=3;
        console.log(a,b,c);
    }
    console.log(a,b,c)
}

f()

```

선언하기 전에 어떠짓도 할수없다.

TDZ에 걸린다.

즉시실행함수 <- 튜터님이 자주 쓰진않는다고 하셧다.

다만 어느때에 적재적소로 사용할수있는지는

알아두자.

다만 즉시실행함수대신 let을 사용해서 해결할수있는경우가 많은가?

for문의 i를 살려야할때

예를들면

```js
var funcs = []
for (var i = 0; i < 10; i++) {
  funcs.push(function () {
    console.log(i)
  })
}
funcs.forEach(function (f) {
  f()
})
```

이함수는 funcs 리스트안에 함수가 push된다. 10개가.
이때 i를 살리고싶은 의도로 작성하였으나
결과는

실제로 실행되는 시점이 forEach가 실행될때

변수의 매칭이 이루어진다. 변수를 찾는다.

근데 이미 i는 10까지 늘어난상태

그래서 결과가 10이 10번찍힌다

해결방법은

1. let을 사용한다.  
2. 즉시실행함수를 사용한다.

closure 공부할때 보자 (ES5 이슈라고 한다.)

closure ?

찾아보는데 너무 머리가아프다.

사용하는 이유만 기억하고 나중에 필요할때 찾아보도록하자.

> ## closure 효능(?)
1. 전역 변수 억제  
2. 특정 함수에 사용자가 정의한 객체 메서드 연결  
3. 함수 캡슐화  
4. setTimeout()  
5. 실수

[reference:ES5_closure](https://rootjang92.github.io/2018/09/14/closure/)

## const : constant variable

상수 변수 ? 이게 말이안된다.

PI : 언젠가 누가 만들었지만

얘는 상수다.

어떤값이 상수다 -> 알파요 오메가 늘 영원히 언제나 그 값을 의미하는것인가?

상수-> 선언하고 그값을 지정한 순간부터다.

형영모순같지만 모순이아니다.

const a;
a=20;

이거 안된다.

바로 에러 발생 상수라고했는데 왜 값을 안넣냐 하는 에러.

기본적으로 const pointer 개념과

뭐 어렵지않는 C++ 내용들이 주로 나오는거같다.

garbage collector: 이거 진짜 좋음 ㅠㅠ

const 객체 
등등 해서 reference 이런거 좀 신경 써야 할꺼같긴하다.

나는 c,c++과 친숙해서 포인터개념이 잘잡혀있다.


하지만 실상 사용하는건 대부분이 reference이다.

포인팅이되는데 값으로 접근하는 친구다.

이런 포인팅장난할때 레퍼런스와 포인터를 착각하지않도록 해야할꺼같다.

## Object.freeze 와 deep copy 

딥카피는 또 c++에서 빠질수없는 핵심이다.

가벼운복사와 깊은복사 매우 중요시 여겼던 기억이난다.

freeze는? 얼린다.

1) Obj 자체 를 얼린다.
2) Obj 내부의 프로퍼티들을 순회하면서, 혹시 참조형이면 , 1)반복 - > 재귀

DeepFreezing
이라고 하며


깊은복사, 얕은복사

얕은복사 : 객체의 프로퍼티들을 복사 (depth 1단계 까지만)

깊은복사 : 객체의 프로퍼티들을 복사 (모든 depth에 대해서)

1) 프로퍼티들을 복사한다.
2) 프로퍼티들 중에 참조형이있으면 , 1) 반복, --> 재귀

얕은복사

```js
var a={
    a:1,
    b:[1,2,3],
    c:{d:1,e:2}
}

var b= Object.assign({},a); // 빈객체넣고 a

```

이것이 얕은복사가 된다.

왜? `b.b[1] = 20;` 으로 하면

a.b의 값도 바뀌어있기 때문이다.

즉 얕은복사는 저도 쟤 가르켜 같은느낌으로

해당 주소를 참조한다.

그러므로 값의 변경을 시도할경우

해당 주소를 같이 가리키고 있는 모든 객체에 영향을 줄수있다.


깊은복사를 하려면?

b.b = Object.assign([], a.b);

참조형 데이터가 있는곳으로 가서 다 해줘야한다.

immutable 많이 들었지. 변경할수없는.

불변객체를 말한다.

참조형데이터가 뭐지? 아마 리스트,함수,RegExp(?)

RegExp : Regular Expressions
[생활코딩 참고자료](https://opentutorials.org/course/50/43)


## for문에서의 주의사항

for in은 const 가 된다.

for in문이 특이한것이다.

그냥 for문은 안된다. (let을 쓴다.)

새로등장한 for of도 된다.

그럼 for in문의 const를 쓰는목적?

변경자,반복자의 값변경을 직접적으로 불가능하게하기위함.  
음 ... 거의 불필요하지않은가...?

## let const 공통사항

재선언 이란

```js
var a
var a

var a=0
var a=1
// 문제가없다 ;;
```

___

```js
let b=2;
let b=3; //error
//식별자인  b라고하느녀석이 이미 선언되어있다.
```
### var는 잊어라. let과 const를 쓰자.

let const

그럼 뭘써?

용도가 다르지않아?

하지만 프론트엔드 개발자는 주로 객체를 다룬다

const를 주로 사용하는게 맞다.

어쩌다가 값 자체의 변경이 필요한 예외적인 경우.(let)

객체 - > const

const로 객체를선언해서 프로퍼티를 변경하면 되니까.

그런식으로 짜야한다

?????


이게 객체지향아닌가.

즉 내가 짜오던 함수형 코딩방식은

객체를 거의 사용하지않는 코딩법이였는데

결국 객체를 써야 관리가편하다는 결론이나온다.

접근은 const로 방어하고

내부 프로퍼티들은 바꿔가면서 활용하는식이 맞는거같다.

---



전역 공간에서 var로선언한 변수는

전역변수임과 동시에 전역객체의 프로퍼티가 된다.

양쪽에 다걸린다.

이상하다.

var a=10;

window.a =10

var a =10;

js에서는 전역변수선언을 최소화해라.

이런 문제들이있구나.

함수스코프로 감싸고 , 즉시실행함수쓰고

등등..let const는 안그런다

결론은뭐다? var가 문제야...

문제가 많은 녀석이였네.

let으로 전역변수를쓰면

window객체의 프로퍼티가 되지않는다

그래서 delete하면 사라진다.

var를 전역변수로 생성하면 전역변수이면서
window의 프로퍼티로 인식이되는데
전역변수라 생각하고 지우려고하면 "나 전역객체의 프로퍼티야"
전역객체의 프로퍼티로써 지우려고 하면 "자 전역 변수야"

결론 지울수가없는 상황이 발생한다.

여튼 문제가많은 var이다.